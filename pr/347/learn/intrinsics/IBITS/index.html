<p>layout: book
title: ibits
permalink: /learn/intrinsics/IBITS
—</p>
<h2 id="name"><strong>Name</strong></h2>

<p><strong>ibits</strong>(3) - [BIT MANIPULATION] Bit extraction
(GFDL)</p>

<h2 id="syntax"><strong>Syntax</strong></h2>

<p><strong>result = ibits(i, pos, len)</strong></p>

<h2 id="description"><strong>Description</strong></h2>

<p><strong>ibits</strong> extracts a field of length <strong>len</strong> from <strong>i</strong>, starting from bit position
<strong>pos</strong> and extending left for <strong>len</strong> bits. The result is right-justified and
the remaining bits are zeroed. The value of pos+len must be less than or
equal to the value <strong>bit_size(i)</strong>.</p>

<h2 id="arguments"><strong>Arguments</strong></h2>

<ul>
  <li>
    <p><strong>i</strong>
The type shall be <em>integer</em>.</p>
  </li>
  <li>
    <p><strong>pos</strong>
The type shall be <em>integer</em>. A value of zero refers to the least
significant bit.</p>
  </li>
  <li>
    <p><strong>len</strong>
The type shall be <em>integer</em>.</p>
  </li>
</ul>

<h2 id="returns"><strong>Returns</strong></h2>

<p>The return value is of type <em>integer</em> and of the same kind as <strong>i</strong>.</p>

<h2 id="standard"><strong>Standard</strong></h2>

<p>Fortran 95 and later</p>

<h2 id="see-also"><strong>See Also</strong></h2>

<p><a href="IEOR"><strong>ieor</strong>(3)</a>, 
<a href="IBCLR"><strong>ibclr</strong>(3)</a>,
<a href="NOT"><strong>not</strong>(3)</a>,
<a href="BTEST"><strong>btest</strong>(3)</a>,
<a href="IBCLR"><strong>ibclr</strong>(3)</a>,
<a href="IBSET"><strong>ibset</strong>(3)</a>,
<a href="IAND"><strong>iand</strong>(3)</a>,
<a href="IOR"><strong>ior</strong>(3)</a>,
<a href="IEOR"><strong>ieor</strong>(3)</a>,
<a href="MVBITS"><strong>mvbits</strong>(3)</a>
layout: book
title: ibits
permalink: /learn/intrinsics/IBITS
—</p>
<h2 id="name-1"><strong>Name</strong></h2>

<p><strong>ibits</strong>(3) - [BIT MANIPULATION] Bit extraction
(GFDL)</p>

<h2 id="syntax-1"><strong>Syntax</strong></h2>

<p><strong>result = ibits(i, pos, len)</strong></p>

<h2 id="description-1"><strong>Description</strong></h2>

<p><strong>ibits</strong> extracts a field of length <strong>len</strong> from <strong>i</strong>, starting from bit position
<strong>pos</strong> and extending left for <strong>len</strong> bits. The result is right-justified and
the remaining bits are zeroed. The value of pos+len must be less than or
equal to the value <strong>bit_size(i)</strong>.</p>

<h2 id="arguments-1"><strong>Arguments</strong></h2>

<ul>
  <li>
    <p><strong>i</strong>
The type shall be <em>integer</em>.</p>
  </li>
  <li>
    <p><strong>pos</strong>
The type shall be <em>integer</em>. A value of zero refers to the least
significant bit.</p>
  </li>
  <li>
    <p><strong>len</strong>
The type shall be <em>integer</em>.</p>
  </li>
</ul>

<h2 id="returns-1"><strong>Returns</strong></h2>

<p>The return value is of type <em>integer</em> and of the same kind as <strong>i</strong>.</p>

<h2 id="standard-1"><strong>Standard</strong></h2>

<p>Fortran 95 and later</p>

<h2 id="see-also-1"><strong>See Also</strong></h2>

<p><a href="IEOR"><strong>ieor</strong>(3)</a>, 
<a href="IBCLR"><strong>ibclr</strong>(3)</a>,
<a href="NOT"><strong>not</strong>(3)</a>,
<a href="BTEST"><strong>btest</strong>(3)</a>,
<a href="IBCLR"><strong>ibclr</strong>(3)</a>,
<a href="IBSET"><strong>ibset</strong>(3)</a>,
<a href="IAND"><strong>iand</strong>(3)</a>,
<a href="IOR"><strong>ior</strong>(3)</a>,
<a href="IEOR"><strong>ieor</strong>(3)</a>,
<a href="MVBITS"><strong>mvbits</strong>(3)</a></p>
